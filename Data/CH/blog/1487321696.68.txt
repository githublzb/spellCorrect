PForDelta索引压缩算法和CPU流水线的关系看到此前的博客曾经承诺详细把PForDelta做详细说明，今天花了点时间，写下来，压缩部分没有展开，因为对于搜索引擎来说，解压的速度才是关键，就其解压速度和CPU流水线的关系，在本文做进一步的深入讨论。


   首先来认识一下PForDelta算法。在压缩过程中，文档间距(gap)越小，压缩的效果越好，有研究表明，在索引压缩的过程中gap = 1的情况大约10%。而pfordelta算法对小gap的情况，特别有优势。


   假定一个索引块为8个gap，80%的情况下gap值小于32，小于32的值均可以用一个b = 5bit的数来表示。下面，建立这样一个结构：8*b-bit的常规部分，看作是一个位数组，每个元素占b-bit定长空间，余下的为异常部分，看作是一个整形数组，每个元素占4字节定长空间。假定有这样一个doc序列:23, 41, 8, 12, 30, 68, 18, 45（这是一个已经求过差分后的序列）。通过pfordelta方法的构造得到如下压缩结构：


   


   


   


    椭圆框所示的部分为常规部分，常规部分的第一个值1，表示从该地址开始，跳过1个地址，就可以找到下一个异常值的位置，同理第三个值3表示，跳过3个地址，就是下一个异常值的位置。常规值从前到后存储，异常值从后向前存储。用二进制形式存储形式如下：


   


   


   


    竖线隔开的是5个整型，前2个存储常规部分，后3个存储异常部分。值得注意的是存储的顺序和跨块的问题，其中第7个位置跨了32bit整形，因此对于1，其一部分在第一个整形，另一部分在第二个整形，同时注意bit写入的时候，从低位往高位顺序写入，最后为了保证异常部分的地址能够按整型取得，对常规部分的剩余部分补零，解码过程中一旦出现零或剩余位不满b-bit，则表示常规部分已经结束。


   


    我们这里只了解一下压缩后的形式，不讨论如何压缩的问题，仅就解压来考察如何将代码改为流水线友好的代码。


   首先，假定之前执行了一个将8个b-bit构成的2个整数（常规部分）和3个整数（异常部分）解压到11个整型的数组block中，依次为[1,23,3,8,12,30,1,18,45,68,41]，我们的目标是将该序列 还原为原始序列[23, 41, 8, 12, 30, 68, 18, 45]。在对这个结构进行解码时，很容易想到需要对常规部分和异常部分做不同的解码操作，


   如下：


   exception_pos = block[0]+1;


   for(size_t i=0,j=size_of_block;i&lt;decompressed_num;i++)


   {


    if(i!=exception_pos)


    {


        result[i]=block[i+1];


    }


       else


     {


              result[i]= block[--j];


        exception_pos+=block[i+1]+1;


         }


   } 


   在循环中出现if判断，两个分支指令会影响流水线的流畅性，如何修改可以去掉这个if语句呢？我们采用两趟循环的方法来处理。


   for(size_t i=0;i&lt; decompressed_num;i++)


   {


    result[i]=block[i+1;


   }


   exception_pos = block[0]+1;


   for(size_t i= exception_pos,j= size_of_block;i&lt; size_of_block;i+= block[i]+1)


   {


   {


    result[i]= block[--j]; 


    }


   }


   虽然做了两趟处理但由于充分利用了流水线的特性，代码执行速度大大加快，当然pfordelta算法并不是这样简单，只是出于举例简化的需要，感兴趣的读者可以参考推荐阅读[1]给出的详细代码。


   


   参考阅读【1】貌似已经停止共享了，我写了一个简单的实现，供大家参考：http://blog.csdn.net/pennyliang/archive/2010/11/30/6045965.aspx


   2010-11-30


   


   【推荐阅读】


   


   


   [1] http://code.google.com/p/integer-array-compress-kit/


   [2] http://blog.csdn.net/pennyliang/archive/2010/08/01/5781214.aspx