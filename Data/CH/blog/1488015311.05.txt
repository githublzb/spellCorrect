在一台linux机器上启动多个redis实例:学习redis的master-slave功能linux机器上安装redis是非常容易的，这里不做介绍了。因为要学习主从复制功能，而我手上又只有一台机器，所以就需要在一台机器上启动多个redis实例。我们需要将默认的redis.conf文件复制一份，然后修改一下对应的设置就可以了，保证多个redis实例不出现共享数据就可以了。


   #拷贝一份新的配置文件
&gt;cp redis.conf redis6001.conf

#vi修改对应的配置项
&gt;vi redis6001.conf

#主要修改下面3个配置项就可以了
pidfile : /var/run/redis_6380.pid
port 6001
rdbfile : dump6001.rdb

   


   



然后我们就可以redis-server指定新的配置文件，这样就可以启动一个新的redis实例。
   redis-server redis6001.conf

   


   



如何配置一个从服务器是非常简单的，比如我们在6001和6002端口启动2个redis实例，想让6001作为master，6002作为slave，那么我们只需要在redis6002.conf中配置如下：
   slaveof 127.0.0.1 6001

   




   




   






   从Redis2.6开始，从服务器支持只读模式，并且该模式为从服务器的默认模式。只读模式由 redis.conf 文件中的 slave-read-only 选项控制。只读从服务器会拒绝执行任何写命令， 所以不会出现因为操作失误而将数据不小心写入到了从服务器的情况。


   




   




   




   


   




   




   如果因为网络故障，slave不能连接到master，那么我们可以通过slave-serve-stale-data配置是否让slave继续提供服务。


   




   




   




   从Redis2.8开始，为了保证数据的安全性，可以通过配置， 让主服务器只在有至少 N 个当前已连接从服务器的情况下，才执行写命令。不过， 因为 Redis 使用异步复制， 所以主服务器发送的写数据并不一定会被从服务器接收到， 因此数据丢失的可能性仍然是存在的。如果至少有 min-slaves-to-write 个从服务器， 并且这些服务器的延迟&#20540;都少于 min-slaves-max-lag 秒， 那么主服务器就会执行客户端请求的写操作。你可以将这个特性看作
 CAP 理论中的 C 的条件放宽版本： 尽管不能保证写操作的持久性， 但起码丢失数据的窗口会被严&#26684;限制在指定的秒数中。另一方面， 如果条件达不到 min-slaves-to-write 和 min-slaves-max-lag 所指定的条件， 那么写操作就不会被执行， 主服务器会向请求执行写操作的客户端返回一个错误。




   




   




   无论是初次连接还是重新连接， 当建立一个从服务器时的时候， 从服务器都将向主服务器发送一个 SYNC 命令。接到 SYNC 命令的主服务器将开始执行BGSAVE ， 并在保存操作执行期间， 将所有新执行的写入命令都保存到一个缓冲区里面。当 BGSAVE 执行完毕后， 主服务器将执行保存操作所得的 .rdb 文件发送给从服务器， 从服务器接收这个 .rdb 文件， 并将文件中的数据载入到内存中。之后主服务器会以 Redis 命令协议的&#26684;式， 将写命令缓冲区中积累的所有内容都发送给从服务器。即使有多个从服务器同时向主服务器发送
 SYNC ， 主服务器也只需执行一次 BGSAVE 命令， 就可以处理所有这些从服务器的同步请求。从服务器可以在主从服务器之间的连接断开时进行自动重连， 在 Redis 2.8 版本之前， 断线之后重连的从服务器总要执行一次完整重同步（full resynchronization）操作， 但是从 Redis 2.8 版本开始， 从服务器可以根据主服务器的情况来选择执行完整重同步还是部分重同步（partial resynchronization）。