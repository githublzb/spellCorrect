分治法解决大整数乘法问题通常，在分析算法的计算复杂性时，都将加法和乘法运算当作基本运算来处理，即将执行一次加法或乘法运算所需的计算时间，当作一个仅取决于计算机硬件处理速度的常数。这个假定仅在参加运算的整数能在计算机硬件对整数的表示范围内直接处理才是合理的。然而，在某些情况下，要处理很大的整数，它无法在计算机硬件能直接表示的整数范围内进行处理。若用浮点数来表示它，则只能近&#20284;的表示它的大小，计算结果中的有效数字也受到限制。若要精确地表示大整数并在计算结果中要求精确地得到所有位数上的数字，就必须用软件的方法来实现大整数的算术运算。

 设X和Y都是n位的二进制整数，现在要计算它们的乘积Z。可以用小学所学的方法来设计计算乘积XY的算法，但是这样做计算步骤太多，效率较低。如果将每2个1位数的乘法或加法看作一步运算，那么这种方法要进行O(n^2)步运算才能算出乘积XY。下面用分治法来设计更有效额大整数乘积算法。


    将n位二进制数X和Y都分为两段，每段长n/2位（为简单起见，假设n是2的幂）。则有：








    其中X1、Xo分别为X的高位和低位，Y1、Yo分别为Y的高位和低位。C2是它们的前半部分的积；Co是它们后半部分的积；C1是X、Y两部分的和的积减去C2与C0的积。如果n/2也是偶数，我们可以利用相同的方法来计算C2、Co的和C1。因此我们就得到了一个计算n位数积的递归算法：





 在这种完美的形式下,当n变成1时,递归就停止了.或者当我们认为n已经够小了,小到可以直接对这样大小的数相乘时,递归就可以停止了.


    该算法会有多少次位乘呢?因为n位数的乘法需要对n/2位数做三次乘法运算,乘法次数M(n)的递推式将会是:

 当n&gt;1时,M(n)=3M(n/2),M(1)=1

 当n=2^k时,我们可以用反向替换法对它求解:












   因为













    在最后一步中,我们利用了对数的一个特性:









    我们应当知道对于不是很大的数,该算法的运行时间很可能比经典算法长.有报告显示,从大于600位的整数开始,分治法的性能超越了笔算算法的性能.

 如果我们使用类&#20284;Java、C&#43;&#43;和Smalltalk这样的面向对象语言，会发现这些语言专门为处理大整数提供了一些类。