&lt;&lt;Combating Web Spam with TrustRank&gt;&gt;的实验这篇论文是我这几天看到写得最好的一篇论文。


   以下是按照论文做的若干实验，和编码，方便自己和看这篇论文的人对照。


   




   


   做rank的代码，我做了简化，看这篇论文的人应该能理解，这种转化是等价的。不多做解释。


   //1)Select Seeds 代码，结果和论文一致，比较精确解如下：


   0.079247

0.135888

0.079247

0.095042

0.086494

0.055128

0.021429




   因此选择page 2,4,5作为种子，这是一种很好的选择种子的方法，即按照outlink的质量来评价，和Pagerank按照inlink质量评价刚好相反，因此用了Inverse transition matrix，同时注意inverse transition matrix 不等价于 transistion matrix的转置。代码如下：


   #include &quot;stdio.h&quot;

int main(void)

{

   double matrix[7][7]={

       {0,   0.5,  0,   0,   0,   0,   0},

       {0,   0,   0.5,  1,   0,   0,   0},

       {0,   0.5,  0,   0,   0,   0,   0},

       {0,   0,   0,   0,   1,   0,   0},

       {0,   0,   0,   0,   0,   1,   1},

       {0,   0,   0.5,  0,   0,   0,   0},

       {0,   0,   0,   0,   0,   0,   0},

   };   

   double r[7][2]={

       {1.0/7,0},

       {1.0/7,0},

       {1.0/7,0},

       {1.0/7,0},

       {1.0/7,0},

       {1.0/7,0},

       {1.0/7,0},

   };

   for(int i= 0; i&lt;20; &#43;&#43;i)        

   {

       int j = i%2;

       int k = (i&#43;1)%2;

       for(int m = 0; m&lt;7;&#43;&#43;m)

       {

           r[m][k] = 0.0;

           for(int n = 0; n&lt;7;&#43;&#43;n)

           {

               r[m][k] &#43;= 0.85*matrix[m][n]*r[n][j];

           }

           r[m][k] &#43;= 0.15/7;

       }

       for(int l = 0;l&lt;7;&#43;&#43;l)

       {

           printf(&quot;%f,%f\n&quot;,r[l][0],r[l][1]);

       }

       printf(&quot;\n&quot;);

   }

   return 0;

}


   计算TrushRank的代码，计算结果与论文一致，精确解，代码如下：


   0.000000

0.179752

0.123260

0.151641

0.128762

0.054913

0.054913


   #include &quot;stdio.h&quot;

int main(void)

{

   double matrix[7][7]={

       {0,   0,   0,   0,   0,   0,   0},

       {1,   0,   1,   0,   0,   0,   0},

       {0,   0.5,  0,   0,   0,   1,   0},

       {0,   0.5,  0,   0,   0,   0,   0},

       {0,   0,   0,   1,   0,   0,   0},

       {0,   0,   0,   0,   0.5,  0,   0},

       {0,   0,   0,   0,   0.5,  0,   0},

   };

   double r[7][2] = {

       {0,0},

       {1.0/2,0},

       {0,0},

       {1.0/2,0},

       {0,0},

       {0,0},

       {0,0},

   };

   double d[]={0,0.5,0,0.5,0,0,0};

   for(int i= 0; i&lt;20; &#43;&#43;i)

   {

       int j = i%2;

       int k = (i&#43;1)%2;

       for(int m = 0; m&lt;7;&#43;&#43;m)

       {

           r[m][k] = 0.0;

           for(int n = 0; n&lt;7;&#43;&#43;n)

           {

               r[m][k] &#43;= 0.85*matrix[m][n]*r[n][j];

           }

           r[m][k] &#43;= 0.15*d[m];

       }

       for(int l = 0;l&lt;7;&#43;&#43;l)

       {

           printf(&quot;%f,%f\n&quot;,r[l][0],r[l][1]);

       }

       printf(&quot;\n&quot;);

   }

   return 0;

}