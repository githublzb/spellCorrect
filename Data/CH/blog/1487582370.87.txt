图像二值化----otsu（最大类间方差法、大津算法）/****************************************以下部分内容为转载**********************************************/


   /*****转自：http://hi.baidu.com/yibobin/blog/item/252573b76fba72f831add1a9.html******/




   最大类间方差法是由日本学者大津于1979年提出的,是一种自适应的阈&#20540;确定的方法,又叫大津

法,简称OTSU。它是按图像的灰度特性,将图像分成背景和目标2部分。背景和目标之间的类间方差

越大,说明构成图像的2部分的差别越大,当部分目标错分为背景或部分背景错分为目标都会导致2部

分差别变小。因此,使类间方差最大的分割意味着错分概率最小。

对于图像I(x,y),前景(即目标)和背景的分割阈&#20540;记作T,属于前景的像素点数占整幅图像的比

例记为ω0,其平均灰度μ0;背景像素点数占整幅图像的比例为ω1,其平均灰度为μ1。图像的总平均

灰度记为μ,类间方差记为g。

假设图像的背景较暗,并且图像的大小为M×N,

图像中像素的灰度&#20540;小于阈&#20540;T的像素个数记作N0,像素灰度大于阈&#20540;T的像素个数记作N1,则有:

　　　　　　ω0=N0/ M×N (1)

　　　　　　ω1=N1/ M×N (2)

　　　　　　N0&#43;N1=M×N (3)

　　　　　　ω0&#43;ω1=1 (4)

　　　　　　μ=ω0*μ0&#43;ω1*μ1 (5)

　　　　　　g=ω0(μ0-μ)^2&#43;ω1(μ1-μ)^2 (6)

将式(5)代入式(6),得到等价公式: g=ω0ω1(μ0-μ1)^2 (7)

采用遍历的方法得到使类间方差最大的阈&#20540;T,即为所求。



   Otsu算法步骤如下：

设图象包含L个灰度级(0,1…,L-1)，灰度&#20540;为i的的象素点数为Ni ，图象总的象素点数为N=N0&#43;N1&#43;...&#43;N(L-1)。灰度&#20540;为i的点的概为：

P(i) = N(i)/N.

门限t将整幅图象分为暗区c1和亮区c2两类，则类间方差σ是t的函数：

σ=a1*a2(u1-u2)^2 (2)

式中，aj 为类cj的面积与图象总面积之比，a1 = sum(P(i)) i-&gt;t, a2 = 1-a1; uj为类cj的均&#20540;，u1 = sum(i*P(i))/a1 0-&gt;t,

u2 = sum(i*P(i))/a2, t&#43;1-&gt;L-1

该法选择最佳门限t^ 使类间方差最大，即：令Δu=u1-u2，σb = max{a1(t)*a2(t)Δu^2}


   /****************************************以下部分内容为原创；OTSU代码**********************************************/




   首先是自己实现的OTSU，原来不知道MATLAB直接有就自己编了……崩溃啊！


   


   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%OTSU 最大类间方差法图像分类
%该方法将图像分为前景和背景两部分，背景和目标之间的类间方差越大,说明构成图像的2部分的差别越大,
%当部分目标错分为背景或部分背景错分为目标都会导致2部分差别变小。因此,使类间方差最大的分割意味着错分概率最小。
%Command 中调用方式： OTSU('D:\Images\pic_loc\1870405130305041503.jpg')
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function th=thresh_md(a); 
   x=imread(a); 
   a=rgb2gray(x); 
   subplot(211);
   imshow(a,[]);
   %[count x]=imhist(a); 
   [m,n]=size(a); 
   N=m*n; 
   L=256; 
   
for i=1:L
    count(i)=length(find(a==(i-1)));
    f(i)=count(i)/(N);
end

for i=1:L 
    if count(i)~=0 
 st=i-1; 
 break; 
    end 
end 
for i=L:-1:1 
    if count(i)~=0 
 nd=i-1; 
 break; 
    end 
end 
%f=count(st+1:nd+1);  %f是每个灰度出现的概率 
p=st;   q=nd-st; 
u=0; 
for i=1:q 
    u=u+f(i)*(p+i-1);  %u是像素的平均值  
    ua(i)=u;    %ua（i）是前i个像素的平均灰度值 
end; 
 
for i=1:q 
    w(i)=sum(f(1:i));  %w（i）是前i个像素的累加概率 
end; 

w=w+0.0001;
 
d=(u*w-ua).^2./(w.*(1-w)); 
[y,tp]=max(d);  %可以取出数组的最大值及取最大值的点 
th=tp+p; 

for i=1:m 
    for j=1:n 
 if a(i,j)&gt;th 
     a(i,j)=0; 
 else 
     a(i,j)=255; 
 end 
    end 
end  
subplot(212);
imshow(a,[]);

下面直接调用MATLAB的函数：

   


   




   


   I=imread('D:\Images\pic_loc\1870405130305041503.jpg');
a=rgb2gray(I);
level = graythresh(a);
a=im2bw(a,level);
imshow(a,[]);



实验结果：