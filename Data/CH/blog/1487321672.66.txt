汇编级代码优化代码优化的含义:代码优化的目标当然是体积小和速度快,但是在通常的情况下二者就象鱼和熊掌一样不能得兼,我们通常寻找的是这二者的折中,究竟应该偏向何方,那就得具体看我们的实际需要.但有些常识是我们应该牢记的,下面就结合我们最常遇到的具体情况来漫谈一下:1.寄存器清0我绝对不想再看到下面的写法:1)moveax,00000000h;5bytes看起来上面的写法很符合逻辑,但你应当意识到还有更加优化的写法:2)subeax,eax;2bytes3)xoreax,eax;2bytes看看后面的字节数你就应该理解为什么要这么作了,除此之外,在速度上也没有损失,他们一样快,但你喜欢xor还是sub呢?我是比较喜欢xor,原因很简单,因为我数学不好....不过Microsoft比较喜欢sub....我们知道windows运行的慢....(呵呵,当然是玩笑这并不是真正原因X-D!)2.测试寄存器是否为0我也不希望看到下面的代码:1)cmpeax,00000000h;5bytesje_label_;2/6bytes(short/near)[*注意很多指令针对eax作了优化,你要尽可能多地实用eax,比如CMPEAX,12345678h(5bytes)如果你使用其他寄存器,就是6bytes*]让我们看看,简单的比较指令居然要用7/11bytes,NoNoNo,试试下面的写法:2)oreax,eax;2bytesje_label_;2/6(short/near)3)testeax,eax;2bytesje_label_;2/6(short/near)呵呵,只有4/8bytes,看看我们可节省多少字节啊3/4字节...那么接下来的问题是你喜欢OR还是TEST呢,就我个人而言,比较喜欢TEST,因为test不改变任何寄存器,并不向任何寄存器写入内容,这通常能在pentium机上取得更快的执行速度.别高兴的太早,因为还有更值得我们高兴的事情,假如你要判断的的是eax寄存器,那么看看下面的,是不是更有启发?4)xchgeax,ecx;1bytejecxz_label_;2bytes在短跳转的情况下我们比2)和3)又节省了1字节.oh....___...3.测试寄存器是否为0FFFFFFFFh一些API返回-1,因此如何测试这个值呢?看你可能又要这样:1)cmpeax,0ffffffffh;5bytesje_label_;2/6byteshey,不要这样,写代码的时候想一想,于是有了下面的写法:2)inceax;1byteje_label_;2/6bytesdeceax;1byte可以节省3bytes并且执行速度会更快.4.置寄存器为0FFFFFFFFh看看假如你是Api的作者,如何返回-1?这样吗?1)moveax,0ffffffffh;5bytes看了上面的不会再这么XXX了吧?看看下面的:2)xoreax,eax/subeax,eax;2bytesdeceax;1byte节省一个字!还有写法:3)stc;1bytesbbeax,eax;2bytes这有时还可以优化掉1byte:jnc_label_sbbeax,eax;2bytesonly!_label_:...我们为什么用asm呢?这就是原因.5.寄存器清0并移入低字数值1)xoreax,eax;2bytesmovax,wordptr[esi+xx];4bytes????---&gt;不会吧,这可能是最多初学者的写法了,我当然原来也是,看了benny的文章之后我决定改写为:2)movzxeax,wordptr[esi+xx];4bytes收获2bytes!下面的3)xoreax,eax;2bytesmoval,byteptr[esi+xx];3bytes就相应改为:4)movzxeax,byteptr[esi+xx];4bytes我们应当尽可能利用movzx5)xoreax,eax;2bytesmovax,bx;3bytes因为执行速度不慢并通常能节省字节...6)movzxeax,bx;3bytes6.关于push,下面是着重代码体积的优化,因为寄存器操作总要比内存操作要快.1)moveax,50h;5bytes这样就小了1word2)push50h;2bytespopeax;1byte当操作数只有1字节时候,push只有2bytes,否则就是5bytes,记住!下一个问题,向堆栈中压入7个03)push0;2bytespush0;2bytespush0;2bytespush0;2bytespush0;2bytespush0;2bytespush0;2bytes占用14字节,显然不能满意,优化一下4)xoreax,eax;2bytespusheax;1bytepusheax;1bytepusheax;1bytepusheax;1bytepusheax;1bytepusheax;1bytepusheax;1byte可以更紧凑,但会慢一点的形式如下:5)push7;2bytespopecx;1byte_label_:push0;2bytesloop_label_;2bytes可以节省7字节....有时候你可能会从将一个值从一个内存地址转移到另外内存地址,并且要保存所有寄存器:6)pusheax;1bytemoveax,[ebp+xxxx];6bytesmov[ebp+xxxx],eax;6bytespopeax;1byte试试push,pop7)pushdwordptr[ebp+xxxx];6bytespopdwordptr[ebp+xxxx];6bytes7.乘法当eax已经放入被乘数,要乘28h,如何来写?1)movecx,28h;5bytesmulecx;2bytes好一点的写法如下:2)push28h;2bytespopecx;1bytemulecx;2bytes哇这个更好::3)imuleax,eax,28h;3bytesintel在新CPU中提供新的指令并不是摆设,需要你的使用.8.字符串操作你如何从内存取得一个字节呢?速度快的方案:1)moval/ax/eax,[esi];2/3/2bytesincesi;1byte代码小的方案:2)lodsb/w/d;1byte我比较喜欢lod因为他小,虽然速度慢了点.如何到达字符串尾呢?JQwerty'smethod:9)leaesi,[ebp+asciiz];6bytess_check:lodsb;1bytetestal,al;2bytesjnes_check;2bytesSuper'smethod:10)leaedi,[ebp+asciiz];6bytesxoral,al;2bytess_check:scasb;1bytejnes_check;2byte选择哪一个?Super的在386以下的更快,JQwerty的在486以及pentium上更快,体积一样,选择由你.9.复杂一点的...假设你有一个DWORD表,ebx指向表的开始,ecx是指针,你想给每个doword加1,看看如何作:1)pushad;1byteimulecx,ecx,4;3bytesaddebx,ecx;2bytesincdwordptr[ebx];2bytespopad;1byte可以优化一点,但是好像没人用:2)incdwordptr[ebx+4*ecx];3bytes一条指令就节省6字节,而且速度更快,更易读,但好像没有什么人用?...why?还可以有立即数:3)pushad;1byteimulecx,ecx,4;3bytesaddebx,ecx;2bytesaddebx,1000h;6bytesincdworptr[ebx];2bytespopad;1byte优化为:4)incdwordptr[ebx+4*ecx+1000h];7bytes节省了8字节!看一下lea指令能为我们干点什么呢?leaeax,[12345678h]eax的最后结果是什么呢?正确答案是12345678h.假设EBP=1leaeax,[ebp+12345678h]结果是123456789h....呵呵比较一下:leaeax,[ebp+12345678h];6bytes==========================moveax,12345678h;5bytesaddeax,ebp;2bytes5)看看:moveax,12345678h;5bytesaddeax,ebp;2bytesimulecx,4;3bytesaddeax,ecx;2bytes6)用lea来进行一些计算我门将从体积上得到好处:leaeax,[ebp+ecx*4+12345678h];7bytes速度上一条lea指令更快!不影响标志位...记住下面的格式,在许多地方善用他们你可以节省时间和空间.OPCODE[BASE+INDEX*SCALE+DISPLACEMENT]10.下面是关于病毒重定位优化的,惧毒人士请绕行...下面的代码你不应该陌生1)callgdeltagdelta:popebpsubebp,offsetgdelta在以后的代码中我们这样使用delta来避免重定位问题leaeax,[ebp+variable]这样的指令在应用内存数据的时候是不可避免的,如果能优化一下,我门将会得到数倍收益,打开你的sice或者trw或者ollydbg等调试器,看看:3)leaeax,[ebp+401000h];6bytes假如是下面这样4)leaeax,[ebp+10h];3bytes也就是说如果ebp后面变量是1字节的话,总的指令就只有3字节修改一下最初的格式变为:5)callgdeltagdelta:popebp在某些情况下我们的指令就只有3字节了,可以节省3字节,嘿嘿,让我们看看:6)leaeax,[ebp+variable-gdelta];3bytes和上面的是等效的,但是我们可以节省3字节,看看CIH...11.其他技巧:如果EAX小于80000000h,edx清0:--------------------------------------------------1)xoredx,edx;2bytes,butfaster换种写法：2)cdq;1byte,butslower我一直使用cdq,为什么不呢?体积更小...下面这种情况一般不要使用esp和ebp,使用其他寄存器.-----------------------------------------------------------1)moveax,[ebp];3bytes2)moveax,[esp];3bytes3)moveax,[ebx];2bytes交换寄存器中4个字节的顺序?用bswap---------------------------------------------------------moveax,12345678h;5bytes太长了，这样：bswapeax;2bytes;eax=78563412hnowWannasavesomebytesreplacin'CALL?---------------------------------------1)call_label_;5bytesret;1byte改为如下：2)jmp_label_;2/5(SHORT/NEAR)如果仅仅是优化,并且不需要传递参数,请尽量用jmp代替call比较reg/mem时如何节省时间:------------------------------------------1)cmpreg,[mem];slower这样写：2)cmp[mem],reg;1cyclefaster乘2除2如何节省时间和空间?------------------------------------------------------------1)moveax,1000hmovecx,4;5bytesxoredx,edx;2bytesdivecx;2bytes移位：2)shreax,4;3bytes除法呢？3)movecx,4;5bytesmulecx;2bytes当然也一样拉4)shleax,4;3bytesloop指令------------------------1)dececx;1bytejne_label_;2/6bytes(SHORT/NEAR)分特，loop没学过？2)loop_label_;2bytes再看:3)je$+5;2bytesdececx;1bytejne_label_;2bytes记住loop4)loopXX_label_(XX=E,NE,ZorNZ);2bytesloop体积小,但486以上的cpu上执行速度会慢一点...交换寄存器:---------------------------------------------------------1)pusheax;1bytepushebx;1bytepopeax;1bytepopebx;1byte明明有指令嘛：2)xchgeax,ebx;1byte3)xchgecx,edx;2bytes如果仅仅是想移动数值,用mov,在pentium上会有较好的执行速度:4)movecx,edx;2bytes比较以下程序:--------------------------------------------1)未优化:lbl1:moval,5;2bytesstosb;1bytemoveax,[ebx];2bytesstosb;1byteret;1bytelbl2:moval,6;2bytesstosb;1bytemoveax,[ebx];2bytesstosb;1byteret;1byte---------;14bytes2)优化了:lbl1:moval,5;2byteslbl:stosb;1bytemoveax,[ebx];2bytesstosb;1byteret;1bytelbl2:moval,6;2bytesjmplbl;2bytes要善于利用代码哦:)---------;11bytes读取常数变量,试试在指令中直接定义:-----------------------------moveax,[ebp+variable];6bytes...mov[ebp+variable],eax;6bytes......variabledd12345678h;4bytes2)优化为:moveax,12345678h;5bytesvariable=dwordptr$-4......mov[ebp+variable],eax;6bytes呵呵,好久没看到这么有趣的代码了,前提是编译的时候支持代码段的写入属性要最后介绍未公开指令SALC,现在的调试器都支持...什么含义呢:就是CF位置1的话就将al置为0xff------------------------------------------------------------------1)jc_lbl1;2bytesmoval,0;2bytesjmp_end;2bytes_lbl:moval,0ffh;2bytes_end:...当然用SALC啦2)SALCdb0d6h;1byte;)


   


   转自：http://www.newsmth.net/bbsanc.php?p=567-6-1-3